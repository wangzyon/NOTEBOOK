# 2 编译工具

## 2.1 概述

Make是最常用的构建工具，通过Makefile实现，主要解决两方面问题；其一自动化批量编译链接，避免手动操作；其二，定义`<target>:<prerequisites>`目标和前置项，根据目标和前置项修改时间关系，决定是否执行command，避免全部代码参与编译链接。

## 2.2 使用

### 2.2.1 目标和前置项

```makefile
# 目标main.o, 前置项main.cpp, 前置项可以多个, 用空格分开
# make工具根据main.o和main.cpp的修改时间, 决定是否执行下方的g++命令
# @表示关闭回响, 即不加@在执行make命令时, 会打印g++ -c main.cpp -o main.o 
main.o : main.cpp
	@g++ -c main.cpp -o main.o
	
# 前置项可以为空
clean :
	@rm main.o

# 申明clean为伪目标，make不会检测是否存在clean文件，即把clean当做指令符号
.PHONY : clean
```

### 2.2.2 语法

#### 基本语句

```makefile
# 定义变量，赋值为folder
a := folder

# 为变量a增加内容directory
a +=directory

# 字符串拼接, 结果为beginfolder directoryend
b :=begin$(a)end

# 条件语句
ifeq ()
	command
else
	command
endif
```

#### 函数

```makefile
# wildcard函数，替换bash的通配符
srcfiles := $(wildcard src/*.txt)

# shell函数执行shell命令，定变量c，为执行命令后的输出字符串
c :=$(shell ls)

# info函数，打印信息或变量
$(info xxx)
$(info $(a))

# 模式匹配替换函数，定义变量d，为a每个元素添加-L,%为模式匹配，输出-Lfolder -Ldirectory
d :=$(patsubst %,-L%,$(a))

# 字符串替换函数,把xiao中的x替换为a
e := $(subst x,a,xiao)

# 替换后缀名, 变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。
# 将a变量中所有以.cpp结尾的项替换为.o结尾，并且赋值给name变量
name : $(a:.cpp=.o)
```

#### 通配符

```makefile
# @代指目标项run, <代指第一个前置项即main.o, ^代指所有前置项即main.o sum.o
run : main.o sum.o
	@g++ -c $< -o $@
	@g++ -c $^ -o $@
```

#### 模式匹配

Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。

```makefile
%.o: %.c
	command
```

等同于:

```makefile
f1.o : f1.c
	command
f2.o : f2.c
	command
```

## 2.3 模板

项目目录结构模板：

```
.
|-- Makefile
|-- lean                     # 依赖库
|   |-- curl-7.78.0
|   |-- openssl-1.1.1j
|-- objs                     # 二进制重定向文件
|   `-- main.o
|-- src                      # 源文件
|   |-- main.cpp
|   |-- sum.cpp
|-- include                  # 头文件
|   `-- sum.hpp
`-- workspace                # 工作目录，存放可执行文件或运行时依赖的文件，例如图片
    `-- pro
```

makefile文件：

```makefile
srcs := $(wildcard src/*.cpp)                            # 待编译源文件
objs := $(patsubst src/%.cpp, objs/%.o, $(srcs))         # 编译后二进制文件
mks := $(objs:.o=.mk)                                    # 二进制文件的前置项

# 编译时头文件查询目录
include_paths := /home/practice/learn_make/lean/openssl-1.1.1j/include /home/practice/learn_make/lean/curl-7.78.0/install/include
# 链接时动态库、静态库查询目录
library_paths := /home/practice/learn_make/lean/openssl-1.1.1j/lib /home/practice/learn_make/lean/curl-7.78.0/install/lib
# 参与链接的动态库和静态库
ld_librarys   := ssl crypto curl

run_paths     := $(library_paths:%=-Wl,-rpath=%)  # 运行时动态库查询目录
include_paths := $(include_paths:%=-I%)
library_paths := $(library_paths:%=-L%)
ld_librarys   := $(ld_librarys:%=-l%)

# 若当前动态库存在其他链接库，可以通过配置LD_LIBRARY_PATH，将其他链接库目录添加进来
# export LD_LIBRARY_PATH := /home/practice/learn_make/lean/openssl-1.1.1j/lib

compile_flags := -std=c++11 -w -g -O0 $(include_paths)          # 编译参数 
link_flags    := $(library_paths) $(ld_librarys) $(run_paths)   # 链接参数


# 非clean指令时，将mks文件中的<目标>:<前置项>包含进来
# -include区别于include,当不存在mk文件,但存在mk目标时,将触发mk目标生成来避免错误
ifneq ($(MAKECMDGOALS),clean)
-include $(mks)
endif

# MM表示仅分析cpp中通过双引号include的头文件
# g++ -MM main.cpp -MF main.mk -MT main.o
# 当main.cpp存在#include "sum.hpp"
# 生成mk内容：main.o : main.cpp sum.hpp
# 此时实现hpp头文件变化检测
objs/%.mk : src/%.cpp
	@echo generate dependences $@ from $<
	@mkdir -p $(dir $@)
	@g++ -MM $< -MF $@ -MT $(@:.mk=.o)

# 编译
objs/%.o : src/%.cpp
	@echo compile $<, generate $@
	@mkdir -p $(dir $@)
	@g++ -c $< -o $@ $(compile_flags)

# 链接
workspace/pro : $(objs)
	@echo link $@ from $^
	@g++ $^ -o $@ $(link_flags)

# 打印
pro : workspace/pro
	@echo Compile Finished

# 运行
run : pro
	@cd workspace && ./pro

clean:
	@rm -rf workspace/pro objs

debug:
	@echo srcs is [$(srcs)]
	@echo objs is [$(objs)]

# 伪目标，表示指令
.PHONY : pro clean debug clean
```

> 在编译过程中，关注头文件变化，但一个源文件依赖多个头文件，且经常变换，cpp:hpp方式需要反复修改，一种更好的实现方式是：通过`g++ -MM xx.cpp MF xx.o -MT xx.mk`自动更新xx.o和xx.cpp中头文件的依赖关系，并通过include方式加入makefile中；